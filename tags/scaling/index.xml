<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>bismuthcoin.org – Scaling</title><link>https://alias-bitsignal.github.io/tags/scaling/</link><description>Recent content in Scaling on bismuthcoin.org</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 12 Aug 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://alias-bitsignal.github.io/tags/scaling/index.xml" rel="self" type="application/rss+xml"/><item><title>Beyond DeFi with Bismuth</title><link>https://alias-bitsignal.github.io/blog/2020-08-12-defi/</link><pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate><guid>https://alias-bitsignal.github.io/blog/2020-08-12-defi/</guid><description>
&lt;p>&lt;img src="https://alias-bitsignal.github.io/images/2020-08-12-defi.webp" alt="" loading="lazy" />
The main difference between Bismuth and Ethereum up until this point was the level of contract decentralization.&lt;/p>
&lt;p>In Ethereum, contracts were independent and had their own rules. In Bismuth, contract execution was still in the hands of private key owners, requiring some level of trust between participating parties. While Bismuth drastically improved scaling with its client-oriented approach and selective execution, the reliance on the contract executor was a major drawback.&lt;/p>
&lt;p>It has been generally overlooked, up until this point, that disadvantages of the Bismuth system can be removed while advantages over Ethereum can remain in place by separating contract execution from the signature mechanism and subjecting it to a specific set of rules, enabling DAO, DeFi and contracts to become genuinely more decentralized than those of Ethereum.&lt;/p>
&lt;p>Superiority of the client-oriented approach where consensus on the secondary layer is decided by individual users – as no central authority governs the consensus protocol above the base layer – enables upgrades to the protocol without disrupting existing versions. Therefore, any protocol upgrades can be done in real time and it is only up to users if they decide to accept upgraded versions as they can be running an unlimited number of versions at the same time without any impact on the underlying system.&lt;/p>
&lt;p>This is an axiomatic advantage over all existing smart contract platforms including Tezos, which only offers decentralized upgrades to a centralized smart contract protocol, while Bismuth lets users run all protocols at once.&lt;/p>
&lt;p>Bismuth does not enforce all nodes to be uniform and see through a single set of eyes. Much more similarly to the real world, the Bismuth model gives every participant the right for their own opinion and the way they see reality. If they choose to not comply with the central vision, they are free to have their own: to change it, upgrade it in any way. This practically results in a complete impossibility of forking, because the system is indifferent towards it. Data is data, saved on the chain. Whatever the user does with it is up to them.&lt;/p>
&lt;p>An example of this can be the Bismuth shielded token system, where encrypted data is stored on the chain and makes no sense to those who do not own the keys. However, even those without decryption keys are allowed to transfer those tokens without knowing whether they own them or not, because those with the decryption keys can still see which of the operations are valid and which are not. Shielded tokens are completely decoupled from the core node and the base layer protocol. Upgrading rules to how they or any other contracts are handled has no impact on other users and requires no developer intervention. The truest and final vision of decentralization.&lt;/p>
&lt;p>Extending this model to smart contracts is the next logical step and requires only a simple sequence of new rules, decoupled from the base node – requiring no forking. Such contracts can have an unlimited set of rules and commands within. Practical example follows.&lt;/p>
&lt;h3>Smart contract creation&lt;span class="hx-absolute -hx-mt-20" id="smart-contract-creation">&lt;/span>
&lt;a href="#smart-contract-creation" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>To create a smart contract system, we first need to establish some basic rules. An initial transaction will be needed, which will describe which tokens the system will be using. For this example, we will use isolated tokens. Integration to the existing token infrastructure is preferable and will require an upgrade of the current token system.&lt;/p>
&lt;h3>Transaction data:&lt;span class="hx-absolute -hx-mt-20" id="transaction-data">&lt;/span>
&lt;a href="#transaction-data" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>&lt;code>name:sc01&lt;/code>&lt;/p>
&lt;h3>Transaction operation:&lt;span class="hx-absolute -hx-mt-20" id="transaction-operation">&lt;/span>
&lt;a href="#transaction-operation" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>&lt;code>sc-origin&lt;/code>&lt;/p>
&lt;p>This is everything needed for the transaction itself, because execution rules will be stored in an interpreter. This way, users can choose the interpreter they want to use and they don’t have to share it publicly, allowing for shielded smart contracts without any further effort. You read correct, private contracts by default.&lt;/p>
&lt;p>Local contract configuration:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;pre>&lt;code>{
&amp;#39;contract_name&amp;#39;: &amp;#39;c01&amp;#39;,
&amp;#39;upgradable’: true,
&amp;#39;tokens: &amp;#39;1000000&amp;#39;,
&amp;#39;governance&amp;#39;: &amp;#39;token_vote-c01&amp;#39;,
&amp;#39;start_block&amp;#39; : &amp;#39;3000000&amp;#39;,
&amp;#39;end_block&amp;#39;: &amp;#39;3100000&amp;#39;,
&amp;#39;allowed_operations&amp;#39;: [&amp;#39;sc-payout-c01&amp;#39;, &amp;#39;sc-terminate&amp;#39;, &amp;#39;sc-proposal&amp;#39;, &amp;#39;sc-oracle-vote&amp;#39;]
}&lt;/code>&lt;/pre>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>‘governance’ defines the ruling mechanic outside of the realm of normal transactions, which are all done with private key signatures. This enables unlimited modes of governance including automatic governance based on blockchain events or coordinated oracle voting, singular oracle authority, etc. “c01” signifies custom particular rules that should not be included in any global set, but that’s all for users to agree on.&lt;/p>
&lt;p>‘allowed_operations’ need to be further in Python functions then used by the contract. For example: payout 100 tokens every 50 blocks to the account which received most weighted votes. That would be a simple contract demo. Another demo would be to let users vote on a real world event and then vote on payouts.&lt;/p>
&lt;h3>Local contract executor:&lt;span class="hx-absolute -hx-mt-20" id="local-contract-executor">&lt;/span>
&lt;a href="#local-contract-executor" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>The contract executor (interpretation engine) scans transactions in the ledger, searching for particular operations which are identified in the local contract configuration. Then it runs particular functions, if those operations are within rules of the contract or have not disabled by voting based on predefined rules (‘sc-proposal’ could serve for contract amendment). For example:&lt;/p>
&lt;p>Select all operations “c01“ from the blockchain. Then sort those transactions based on data: proposals, votes. Based on rules set in the contract configuration and functions linked to them, establish whether proposals are valid. Then pass the results of operations to a local database in the same way that aliases or tokens are handled currently in Bismuth. Contracts are directly integrated with oracles as no consensus is enforced.&lt;/p>
&lt;h3>Further scaling proposal&lt;span class="hx-absolute -hx-mt-20" id="further-scaling-proposal">&lt;/span>
&lt;a href="#further-scaling-proposal" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>Due to the nature of these contracts, all data storage can be local, unlimited and fee-less. Even contract rules can be transferred offline, saving on fees and on privacy.&lt;/p>
&lt;p>Should users choose to save more data on the blockchain, it is possible to extend scaling by moving them to a decentralized storage system like IPFS and only reference hashes on the blockchain. Every contract executor can then call IPFS and pull the contract data from there. Further research on data availability may be required.
&lt;img src="https://alias-bitsignal.github.io/images/2020-08-12-002.png" alt="" loading="lazy" />&lt;/p>
&lt;h2>References&lt;span class="hx-absolute -hx-mt-20" id="references">&lt;/span>
&lt;a href="#references" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;ul>
&lt;li>&lt;a href="https://alias-bitsignal.github.io/blog/2018-07-19-semantic/" >Semantic Interpretation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://alias-bitsignal.github.io/blog/2019-09-20-shielded-tokens/" >Shielded Tokens&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Semantic Interpretation</title><link>https://alias-bitsignal.github.io/blog/2018-07-19-semantic/</link><pubDate>Thu, 19 Jul 2018 00:00:00 +0000</pubDate><guid>https://alias-bitsignal.github.io/blog/2018-07-19-semantic/</guid><description>
&lt;p>&lt;img src="https://alias-bitsignal.github.io/images/2018-07-19-semantic-interpretation.webp" alt="" loading="lazy" />
Solution to the codebase consensus conflict in context of the &lt;strong>Bismuth Blockchain&lt;/strong>.&lt;/p>
&lt;h3>The Problem&lt;span class="hx-absolute -hx-mt-20" id="the-problem">&lt;/span>
&lt;a href="#the-problem" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>In 2017, a new type of a 51% attack became prolific. It was not of technical, but of governance (political) nature. The resilience of cryptocurrencies is supposed to lie within decentralization of the network, but the code repository is a single point of failure which became the target for this new type of attack – forking and network hijacking, a type of consensus rule attack.&lt;/p>
&lt;p>Ethereum proved that it is possible to fork a cryptocurrency network, arbitrarily change its contents and win majority of the participants through a public campaign. This opened the door to a new way of thinking – that it is no longer required to fork a codebase to start your own network, but instead it is possible and profitable to hijack an existing network and take
over its participants by promotion. Once the forked codebase wins the majority, it is de facto the winner.&lt;/p>
&lt;h3>Existing Proposals&lt;span class="hx-absolute -hx-mt-20" id="existing-proposals">&lt;/span>
&lt;a href="#existing-proposals" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>A few solutions have been proposed by new projects, most prominent of them is Tezos. Tezos markets itself as the self-amending ledger, where participants can vote on proposals that are eventually integrated into the system. This is an improvement over the existing situation, which in my opinion does not address the problem in an ideal way.&lt;/p>
&lt;h3>Semantic Interpretation Solution&lt;span class="hx-absolute -hx-mt-20" id="semantic-interpretation-solution">&lt;/span>
&lt;a href="#semantic-interpretation-solution" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>I hereby introduce the semantic interpretation approach to the singular codebase problem. In this model, the core system remains untouched and is governed by consensus. The semantic interpretation level exists above the core layer. There, both the secondary layer codebase storage and the way it is interpreted are subject to users. The main advantage is that it can endlessly fork, users can pick which code authors they want to express without influencing others and mainly without having any impact on the
primary level codebase. The main consensus remains the same and the semantic layer is not bound by shared state or enforced using traditional consensus rules.&lt;/p>
&lt;h3>Implementation of Secondary Layer&lt;span class="hx-absolute -hx-mt-20" id="implementation-of-secondary-layer">&lt;/span>
&lt;a href="#implementation-of-secondary-layer" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;h4>Level 1: Passive Data&lt;span class="hx-absolute -hx-mt-20" id="level-1-passive-data">&lt;/span>
&lt;a href="#level-1-passive-data" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>For a system like this, we need a blockchain which enables storage of arbitrary data. The data do not represent a contract of any type, only passive input. This is the first level of interpretation as all users can store data. They can be referred to as service providers.&lt;/p>
&lt;h4>Level 2: Active Interpretation Engines&lt;span class="hx-absolute -hx-mt-20" id="level-2-active-interpretation-engines">&lt;/span>
&lt;a href="#level-2-active-interpretation-engines" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>On the side of the individual users, we need code that interprets the passive data and turns it into meaningful output. An application which analyzes blocks, looking for code the user is interested in. Service providers can distribute such applications, doing this task for the users, so they reach the desired level of communication between users and the service.&lt;/p>
&lt;p>Interpretation engines can then store output on the blockchain again.
This output can be recycled as passive data if desired. Interpretation engines can be thought of as individual contract executors and can be run by one or many nodes, depending on design and the need for particular sub-consensus.&lt;/p>
&lt;h4>Level 3: Conflict Resolution&lt;span class="hx-absolute -hx-mt-20" id="level-3-conflict-resolution">&lt;/span>
&lt;a href="#level-3-conflict-resolution" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>Level 1 conflict is the basis for this system to work. Users do not strive for consensus, instead they choose which services they individually want to use, just like on the internet they pick which websites they want to visit. Therefore, nobody has any power over which data anyone else has to use or execute. They use the shared blockchain database for common storage and availability. Level 2 conflict is similar to a standard blockchain fork. If someone disagrees with an interpretation engine of of a provider and that engine is available openly, they can change it and offer it for the users, becoming a provider of a new solution. Both engines can continue running on the underlying blockchain without any security risks, even if users of a particular engine drop to 0 for any length of time.&lt;/p>
&lt;h3>Practical Example&lt;span class="hx-absolute -hx-mt-20" id="practical-example">&lt;/span>
&lt;a href="#practical-example" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>This scenario deals with a one node example for simplicity. Many node scenario includes handling of user resources whose interpretation does not require shared state consensus, such as tokens.&lt;/p>
&lt;h4>Part 1: Service Provider Emerges&lt;span class="hx-absolute -hx-mt-20" id="part-1-service-provider-emerges">&lt;/span>
&lt;a href="#part-1-service-provider-emerges" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>User with address A decides to become a service provider of a newspaper. He starts a service by submitting news to the blockchain on daily basis, leveraging the availability advantages of such a solution.&lt;/p>
&lt;h4>Part 2: Data Storage and Interpretation Engine Creation&lt;span class="hx-absolute -hx-mt-20" id="part-2-data-storage-and-interpretation-engine-creation">&lt;/span>
&lt;a href="#part-2-data-storage-and-interpretation-engine-creation" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>The provider stores data to the blockchain in a particular form. In the interpretation process, the main trigger is his address and a specific command in the operation field. The news data is stored in the data field. He also creates an application which reads the previously stored data.&lt;/p>
&lt;h4>Data for Interpretation Engine 1:&lt;span class="hx-absolute -hx-mt-20" id="data-for-interpretation-engine-1">&lt;/span>
&lt;a href="#data-for-interpretation-engine-1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>address: 123, operation: newspaper, data: banks bailout in 2019&lt;/p>
&lt;p>&lt;strong>Interpretation Engine 1 pseudocode:&lt;/strong>
Select all data from blockchain where the address is 123, operation is ”newspaper” and block time ranges between last monday and today. Display data from data field to the user using a web interface available through the browser.&lt;/p>
&lt;h4>Part 3: Choice as Consensus Conflict&lt;span class="hx-absolute -hx-mt-20" id="part-3-choice-as-consensus-conflict">&lt;/span>
&lt;a href="#part-3-choice-as-consensus-conflict" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h4>&lt;p>Users A and B decide to download the application and use it. Users C and D ignore it, governance consensus is already split into two groups, one deeming the app worthy, the other one not. If the application was run from a traditional smart contract, this would result in a disruption of the consensus. No such scenario occurs with the Interpretation Engine.
After some time, a new provider decides to copy the Interpretation Engine and issue news in a different language. They change the source address to their own, find new users for it.&lt;/p>
&lt;p>address: 234, operation: newspaper_cz, data: finanční pomoc bankám v r. 2019 (Interpretation Engine 2)&lt;/p>
&lt;p>A third provider chooses to edit this Interpretation Engine to only read news on Monday, utilizing the first data source, but changing the application.&lt;/p>
&lt;p>address: 123, operation: newspaper, data: banks bailout in 2019 (Interpretation Engine 3)&lt;/p>
&lt;h3>Summary&lt;span class="hx-absolute -hx-mt-20" id="summary">&lt;/span>
&lt;a href="#summary" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h3>&lt;p>Interpretation Engines provide a viable solution to the governance problem and consensus centralization in the world of blockchain. Instead of looking for consensus, they intentionally break it without any consequences for the core levels where shared state is critical for operation. It is possible to use them to transfer data and value, run them from one or many nodes, introduce advanced trigger solutions or use one of the existing Bismuth applications as a guideline.&lt;/p>
&lt;h2>Bibliography&lt;span class="hx-absolute -hx-mt-20" id="bibliography">&lt;/span>
&lt;a href="#bibliography" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Goodman, L.M (2014). Tezos Whitepaper. &lt;a href="https://tezos.com/static/papers/white_paper.pdf" target="_blank" rel="noopener">https://tezos.com/static/papers/white_paper.pdf&lt;/a>
2018 bitcoincash.org. Bitcoin Cash. &lt;a href="https://www.bitcoincash.org" target="_blank" rel="noopener">https://www.bitcoincash.org&lt;/a>&lt;/p>
&lt;p>You can also refer to &lt;a href="https://github.com/bismuthfoundation/Hack-with-BIS/tree/master/01-Concepts/protocols" target="_blank" rel="noopener">https://github.com/bismuthfoundation/Hack-with-BIS/tree/master/01-Concepts/protocols&lt;/a> for more doc on existing Bismuth protocols.&lt;/p></description></item></channel></rss>